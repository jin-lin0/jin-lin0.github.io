---
title: 笔试&面试知识
tags:
  - 笔试
  - 前端
categories:
  - 前端
hidden: true
abbrlink: 28300
date: 2024-09-23 22:11:10
---
<!--more-->



## 面试

面试官你好，我叫xxx，目前是电子科技大学软件工程专业的一名研究生，将于明年毕业。在本科和研究生阶段，我主修了计算机网络、数据结构、算法设计与分析等课程，并取得了良好的成绩。在实习经历方面，曾在字节担任过一段时间的前端开发实习生，参与了需求评审、技术方案设计，并承担了商家任务调度平台、818大促活动等多个项目前端开发任务。除此之外，我还开发了个人基于React的前端组件库，使用styled-components和storybook增强项目的可复用性和可维护性。对前端开发的学习很有兴趣，希望可以找到一份前端开发工程师的工作。

1. ##### var、let、const差别

   Var、let、const都可以用作变量的声明。

   var声明的变量会添加到全局对象中，可以使用全局对象进行访问，let和const不能。

   var声明的变量存在变量提升，在声明之前可以访问不会报错，let和const声明的变量存在暂时性死区，不能提前访问。

   let和const是块级作用域，不可以在一个作用域内重复声明，var是函数作用域。

   const声明的常量不可以修改，引用类型不能修改指针。

2. ##### for in和for of的区别

   两者都是遍历的方法，for in用于遍历索引，for of用于遍历元素值。

   for in多用于遍历对象，因为for in在遍历数组的索引的时候，索引的值为字符串类型，同时也会遍历数组的所有可枚举属性，包括原型上的方法和属性，这通常不是我们想要的。

   for of用遍历数/数组对象/字符串/`map`/`set`等拥有迭代器对象（`iterator`）的集合，但是不能遍历对象，因为没有迭代器对象。

3. ##### 延迟加载js的方法

   defer属性

   async属性

   动态创建DOM

   setTimeout延迟加载脚本

   script放到底部加载

4. **盒子模型**

   一个盒子由四部分组成，margin、border、padding、content

   分为两种盒子模型，标准盒子模型（默认）和怪异盒子模型

   标准盒子模型的宽高为content的宽高，box-sizing为content-box

   怪异盒子模型的宽高包括padding和border，box-sizing为border-box

5. **React Fiber**

   Fiber叫做纤程，意思是比线程还要纤细的一个过程，可以对渲染实现更加精细的控制。是React16新架构下的虚拟DOM。Fiber可以把一个渲染任务分解为多个渲染函数，而不是一次性完成，把每一个分割的很细的任务视作执行单元，React会检查还剩多少时间，没有时间会将控制权交出去，中间可以返回主线程或者执行其他任务，实现了增量渲染。

   ### React Fiber 的核心原理

   ##### 1. **可中断的更新过程**

   在 React Fiber 之前，React 使用的协调（Reconciliation）机制是同步的，即一次渲染和更新操作会从头到尾执行完，无法中断。这对于小规模更新是可以接受的，但在大型应用中，可能会导致界面卡顿或丢失响应。React Fiber 通过将渲染任务拆分成更小的单元，并允许任务在必要时中断，从而解决了这一问题。

   - **工作单元（Work Unit）**：在 Fiber 中，React 会将更新任务分割为多个小的工作单元（单位任务），每个单元代表一个 React 元素或组件的更新。
   - **任务的分割与调度**：这些小任务可以被逐个执行，渲染过程不再是不可分割的整体。这使得 React 能够在处理复杂渲染任务时，将这些任务拆分为更小的可中断的工作单元，在必要时暂停当前任务，转而处理更高优先级的任务（如用户交互）。

   ##### 2. **优先级调度**

   React Fiber 的另一个关键特性是**优先级调度**。不同类型的更新具有不同的优先级，例如：

   - 用户输入（如点击或打字）通常是高优先级的。
   - 数据获取或不影响界面流畅性的渲染更新则可以被认为是低优先级的。

   React Fiber 通过引入一个调度器，使得 React 能够根据任务的紧急程度分配不同的优先级。任务的执行顺序不再是简单的“先来先服务”，而是根据优先级动态调整。这样，React 可以在必要时中断低优先级任务，优先处理用户交互等高优先级任务。

   ##### 3. **双缓冲机制**

   React Fiber 使用了一种**双缓冲**（Double Buffering）机制来处理更新工作。它在内存中维护两个 Fiber 树：

   - **current tree（当前树）**：当前正在显示的界面对应的 Fiber 树。
   - **workInProgress tree（工作树）**：正在进行更新的 Fiber 树。

   当 React 处理一个更新时，它会在 `workInProgress tree` 中进行操作，而不影响 `current tree`。一旦 `workInProgress tree` 完成了所有更新，React 会将它与 `current tree` 交换，界面更新才会被应用。这种方式使得整个渲染过程更加平滑，减少了不必要的重绘和性能开销。

   ##### 4. **增量渲染**

   由于 Fiber 允许任务被拆分和中断，React 能够**增量渲染**界面。即便一次更新需要修改大量组件，React 也可以逐步地完成渲染，而不是一次性完成。这样可以避免在一次大的更新中卡顿或丢失响应。

   ##### Fiber 数据结构

   React Fiber 的核心数据结构是**Fiber 节点**，它表示每个组件对应的工作单元。每个 Fiber 节点包含了与组件实例、状态、DOM 节点等相关的详细信息。

   Fiber 节点是一个链表结构，链表的设计便于在 Fiber 树中遍历和更新。每个 Fiber 节点有以下几个重要的字段：

   - **type**：组件的类型，指向 React 组件类、函数组件或原生 DOM 元素。
   - **child**：指向当前节点的子节点。
   - **sibling**：指向当前节点的下一个兄弟节点。
   - **return**：指向当前节点的父节点。
   - **stateNode**：保存当前组件的状态或 DOM 引用。

   这种链表结构使得 Fiber 树可以高效地遍历和更新，并且可以在中断时恢复之前的操作。

   ##### Fiber 的工作流程

   React Fiber 的渲染过程分为两个阶段：

   1. Reconciliation 阶段（调和阶段）
      - 该阶段是逐步遍历 Fiber 树，计算哪些节点需要更新、删除或创建。
      - 这一阶段是**增量可中断**的，可以被暂停以处理更高优先级的任务。
   2. Commit 阶段
      - 当 Reconciliation 阶段完成后，React 会进入提交阶段，将计算好的更新应用到真实的 DOM。
      - 该阶段是**不可中断**的，因为它直接影响用户界面的更新。

5. 

## 笔试

1. 实现逻辑地址到物理地址的转换三种方式：

   绝对装入 (适用于单道程序)
    编译时产生绝对地址，即逻辑地址直接就是物理地址
    一次性将全部进程数据装入内存，装入后物理地址不在改变

   可重定位装入 (静态重定位)
    装入时将逻辑地址转换为物理地址
    例如:逻辑地址为0~5000,内存中从10000开始有空闲区,则逻辑地址0-5000中每个地址均加10000获得物理地址．即逻辑地址加一个偏移，之后物理地址不在改变
    一次性将全部进程数据装入内存，装入后物理地址不在改变

   动态运行时装入 (动态重定位)
    运行时将逻辑地址转换为物理地址，需设置重定位寄存器
    以重定位寄存器中的值作为物理地址的起点然后加上逻辑地址得到物理地址
    程序运行前只装入部分代码，运行期间根据需要动态申请分配内存

2. **适配器模式与桥接模式的区别和联系**

      适配器模式和桥接模式都是间接引用对象，因此可以使系统更灵活，在实现上都涉及从自身以外的一个接口向被引用的对象发出请求。

      两种模式的区别在于使用场合的不同，适配器模式主要解决两个已经有接口间的匹配问题，这种情况下被适配的接口的实现往往是一个黑匣子。我们不想，也不能修改这个接口及其实现。同时也不可能控制其演化，只要相关的对象能与系统定义的接口协同工作即可。适配器模式经常被用在与第三方产品的功能集成上，采用该模式适应新类型的增加的方式是开发针对这个类型的适配器

   桥接模式则不同，参与桥接的接口是稳定的，用户可以扩展和修改桥接中的类，但是不能改变接口。桥接模式通过接口继承实现或者类继承实现功能扩展

3. IP地址划分
   - A类地址：`1.0.0.1～126.255.255.254`
   - B类地址：`128.0.0.1～191.255.255.254`
   - C类地址：`192.168.0.0～192.168.255.255`
   - D类地址：`224.0.0.1～239.255.255.254`
   - E类地址：`240.0.0.1～255.255.255.254`

4. 文法

   描述语言语法结构的形式规则，四元组`G={VN,VT,P,S}`

   VN:非终结符；VT：终结符；P：产生式集合；S：文法的开始符号

   终结符：小写字母、运算符、标点符号、数字、粗体字符串

   非终结符：大写字母、字母S、小写斜体的名字、代表程序构造的大写字母

5. 中间语言

   中间语言(中间代码)是一种面向语法，易于翻译成目标程序和源程序的等效内部表示代码。其可理解性及易于生成目标代码的程度介于源语言和目标语言之间。常用的中间语言有逆波兰表示、四元式、三元式和树表示等。对于中间语言，要求其不但与机器无关，而且有利于代码生成。

6. parseInt中如果第一个参数字符不是指定 `radix` 参数中的数字，它将忽略该字符以及所有后续字符，并返回到该点为止已解析的整数值。`parseInt` 将数字截断为整数值。允许前导和尾随空格。比如`parseInt("10+15",2)`

6. 构造函数如果返回值是引用类型则直接返回，如果是基本类型或没有显式返回，则返回创建的实例对象

## 项目

1. 在商家任务调度系统的前端开发中，我遇到的最大难点是**任务列表展示的性能优化**。由于用户任务量可能非常庞大，前端需要高效渲染和管理大量的任务数据。如果不加以优化，一次性加载过多的数据会导致页面渲染缓慢，用户体验变差，尤其是在任务列表分页加载和任务状态频繁更新的情况下，保持流畅的用户体验是一个挑战。

   **为了解决这个问题，我采取了以下几项措施：**

   1. **虚拟列表（Virtual Scrolling）**
      由于任务数据量巨大，我采用了虚拟列表技术，使页面只渲染当前视窗内可见的数据，而非一次性加载所有任务。这种方式大大减少了DOM元素的数量，避免了浏览器渲染瓶颈，显著提升了页面性能和响应速度。用户在滚动页面时，数据会动态加载，保证了在任务量较大时也能保持流畅的操作体验。
   2. **任务状态的精准管理**
      商家任务通常有多种状态，例如待处理、进行中和已完成，前端需要实时地展示这些状态变化。我使用了Redux管理全局状态，通过Redux的**中间件（middleware）\**处理异步操作，确保在任务状态变化时，前端能够及时响应并更新UI。与此同时，我还使用了\**React的memoization技术**（如`useMemo`、`useCallback`），避免了不必要的组件重新渲染，进一步提高了渲染效率。
   3. **数据交互优化**
      为了确保任务数据与后端的同步，我使用了**乐观更新**策略。在用户操作如创建或更新任务时，前端会立即更新UI，而不是等待后端响应，优化了用户操作的响应速度。在后台，我通过WebSocket实现与后端的实时通信，确保任务数据和状态的变化能够在前端立即反映，而不需要频繁轮询API，这也降低了服务器压力。

   通过这些技术手段，我不仅解决了大数据量下的渲染性能问题，还保证了任务状态更新的实时性和用户体验的流畅性。系统上线后，任务管理界面即使在高并发情况下依然能够保持良好的性能，用户反馈也十分积极。

2. 虚拟列表相关

   - 如何实现

     具体的实现方式是基于**React**，通过控制可视区域内的DOM渲染来实现按需加载。我使用了以下几个核心技术点：

     1. **可视窗口计算**：首先，通过监听`scroll`事件，动态计算用户当前所处的滚动位置和可视区域范围。每次滚动时，系统会根据用户的当前位置，确定只渲染可视区域内的任务项，其余部分则不渲染，或者只占位不加载实际内容。
     2. **高度估算和定位**：在虚拟列表中，为了准确显示滚动位置并确保用户滚动时列表流畅，我对每个任务项的高度进行了预估或设置为固定高度。如果任务项高度不固定，会实时计算实际高度，并动态调整滚动范围。通过这种方式，确保用户可以平滑地滚动到指定位置，且任务项能够正确显示。
     3. **React框架支持**：我使用了`react-window`和`react-virtualized`等成熟的虚拟列表库，这些库已经封装了核心的虚拟滚动逻辑，并提供了高效的渲染和滚动机制。我选择`react-window`主要是因为其体积小、性能高，更适合我们这个项目中需要处理大量数据的场景。

   - 快速滚动情况处理

     在虚拟列表中，会遇到用户需要跳转到指定任务或特定位置的情况，而虚拟滚动依赖于视窗内的数据渲染。如果直接滚动到目标位置，可能会出现页面加载延迟，影响体验。

     为了解决这个问题，我采取了**分段加载**和**索引预计算**的方式：

     1. **分段加载**：我们可以将任务列表按页或分段缓存，用户在跳转时先加载目标位置附近的数据，确保用户在跳转后不会有明显的等待时间。
     2. **索引预计算**：我会预计算每个任务的高度或大致范围，以便快速确定目标任务的渲染位置，从而避免滚动过程中的卡顿。

     此外，通过监听用户的快速滚动行为，提前加载目标附近的数据，确保在用户到达目标位置前数据已经准备好，提升体验流畅度。

     ###  **难点分析**

     #### 1.1 **高并发性能优化**

     由于大促活动页在短时间内会吸引大量用户访问，因此页面的性能优化至关重要。在面对高并发访问时，前端需要确保页面响应迅速、加载流畅。这涉及到多个层面的优化：

     - **懒加载与资源压缩**：通过懒加载图片、按需加载模块，减少初始页面加载时间。使用 Webpack 进行代码分割，减少打包文件的体积，并对 JavaScript、CSS 等进行压缩和混淆。
     - **CDN 加速**：利用内容分发网络（CDN）缓存静态资源（如图片、JS、CSS 文件），提高用户从服务器获取资源的速度，降低服务器压力。
     - **异步数据请求与骨架屏**：在请求数据时，使用异步加载策略，避免页面首次加载时被阻塞。同时，使用骨架屏技术，使页面在内容未完全加载时依旧展示友好的 UI，提升用户体验。

     #### 1.2 **跨端适配**

     由于大促活动页通常需要兼顾移动端和 PC 端的用户访问，跨端适配是一个重要挑战。尤其是针对不同尺寸和分辨率的设备，保证页面布局和交互的一致性和适应性。

     - **响应式设计**：使用 `flexbox` 或 `grid` 等布局方式进行响应式设计，结合媒体查询根据不同设备调整布局和样式。
     - **Viewport 配置与动态适配**：移动端需要合理设置 `viewport`，并通过 JS 动态调整页面的字体大小和布局，以适应不同的屏幕尺寸。

     #### 1.3 **复杂的交互效果**

     大促活动页为了吸引用户，通常会涉及到复杂的动画效果和互动设计，如限时抢购倒计时、滚动特效、滑动切换等。这对性能和开发调试提出了更高的要求：

     - **CSS 动画与性能优化**：通过使用 `transform` 和 `opacity` 等属性进行硬件加速的 CSS 动画，避免使用导致回流和重绘的属性（如 `top`、`left` 等）。
     - **节流与防抖**：在复杂的滚动、点击等交互事件中，使用节流与防抖技术减少对 DOM 的频繁操作，提升性能。

     #### 1.4 **数据埋点与分析**

     活动页通常需要进行用户行为跟踪、点击统计等数据埋点，帮助产品团队分析用户行为，优化后续活动设计。埋点需要精准，且对性能的影响要尽量小。

     - **无侵入式埋点**：通过事件委托等方式，实现对特定区域或元素的点击、浏览等行为的监听，而不是在每个元素上绑定事件。
     - **数据打点与上报优化**：结合数据上报的节流机制，避免过于频繁的上报请求对页面性能造成负面影响。

     ### 

### QS

#### CSS

##### CSS三大特性

层叠性：CSS样式的叠加，遵循就近原则

继承性：书写CSS样式，子标签继承父标签的某些样式

优先级：继承样式权重为0，权重相同时候，遵循就近原则

##### 垂直水平居中的方式

1. flex布局

   ```css
   .outer {
     display: flex;
     justify-content: center; /* 水平居中 */
     align-items: center; /* 垂直居中 */
   }
   ```

2. grid布局

   ```
   .outer {
     display: grid;
   }
   
   .inner {
     justify-self: center; /* 水平居中 */
     align-self: center; /* 垂直居中 */
   }
   ```

3. 父元素display:table-cell;vertical-align:center

4. 子绝父相

   ```css
   .outer {
     position: relative;
   }
   
   .inner {
     position: absolute;
     left: 50%;
     top: 50%;
     transform: translate(-50%, -50%);
   }
   ```

```css
.outer {
  position: relative;
}

.inner {
  position: absolute;
  left: calc(50% - 50px);
  top: calc(50% - 50px);
}
```

```css
.outer {
  position: relative;
}

.inner {
  position: absolute;
  left: 50%;
  top: 50%;
  margin-left: -50px;
  margin-top: -50px;
}
```

```css
.outer {
  position: relative;
}

.inner {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  margin: auto;
}
```

##### block、inline和inline-block的区别

块级元素拥有自己的宽高，可以自定义weight和height，独占一行

行内元素不可以设置宽高，可以与其他行内元素位于同一行，特别注意，img为行内元素，但是可替代元素可以设置宽高

行内块可以一行放置多个行内块元素，可以自由设置高度和宽度

inline元素只能设定左右margin、padding，上下的是不起作用的

##### position属性的值包括什么

static、absolute、relative、fixed、sticky

##### 重绘和重排

##### Flex实现112布局

##### CSS隐藏元素的三种方式

1. `display: none;`：完全移除元素，不占据任何空间。
2. `visibility: hidden;`：元素不可见，但仍占据空间，不可点击。
3. `opacity: 0;`：元素不可见，但仍然在文档流中，可以点击。

##### css绘制一个半圆

```css
#half_circle1 {
  width: 200px;
  height: 100px;
  background: #000;
  border-radius: 100px 100px 0 0;
}
```

##### CSS硬件加速的属性有什么？

transform opacity filter will-change 创建独立层，脱离了文档流

#### JS

##### 手写bind、apply、call

##### JS的数据类型有哪些？判断数据类型的方法？

基本数据类型包括Number、String、Boolean、Null、Undefined、Symbol、BigInt

引用数据类型包括Object

判断数据类型的方法有typeof、instanceof、Object.prototype.toString.call()

##### ==和===的区别

==叫做相等运算符，===叫做严格运算符

==在比较相同类型的数据，与严格运算符完全一致

比较不同数据类型的时候，原始类型会转为数值进行比较、对象与原始类型进行比较时，对象会转为原始类型的值进行比较。undefined和null与其他类型的值比较的时候，结果都为false，它们互相比较的时候，结果为true。

##### JS判断整数

1. 取余数运算符但需要判断是数字
2. Number.isIntege()
3. 使用Math.round、Math.ceil、Math.floor判断，整数取整后还是自己
4. parseInt取整后还是自己判断
5. 位运算判断(obj | 0) === obj，但是只能处理32位以内的

##### js获取DOM元素的方法

1. document.getElementById(“domId”)
2. document.getElementsByName(“domName”)
3. document.getElementsByTagName(“tagName”)
4. document.getElementsByClassName(“classNames”)
5. document.querySelectorAll(“selector”)

##### js执行上下文

分为三种：

全局执行上下文：任何不在函数内部的代码都在全局执行上下文中，会创建全局windows对象，并将this指向全局对象，一个程序只会有一个全局执行上下文

函数执行上下文：函数被调用的时候创建

Eval函数执行上下文：eval函数内部的执行上下文，不常用

##### map和weakmap的区别

map可以使用任意类型的值作为键，weakmap使用对象的引用作为键

weakmap里无引用的对象，会被垃圾回收机制自动清除集合。

map有内置的迭代器，可以使用for of遍历，weakmap不可以。

##### 原型链？判断原型的方法？

原型链是实现对象继承的一种机制，每个对象有一个内部属性，执行它的原型对象。访问对象某个属性的时候，如果该属性不存在于对象自身，js会沿着原型链向上寻找，直到null。每个对象都有一个 `[[Prototype]]`，可以通过 `__proto__` 来访问，现代浏览器中也可以通过 `Object.getPrototypeOf()` 方法来获取对象的原型。每个构造函数（如 `function`、`Array` 等）都有一个 `prototype` 属性，这个属性指向一个对象，这个对象就是由该构造函数创建的所有实例的原型对象.

判断原型的方法有

1. instanceof运算符，在跨不同的JS环境比如不同的iframe里面可能会失效
2. isPrototypeOf 不依赖于构造函数更加灵活
3. Object.getPrototypeOf 直接访问和比较对象的原型

##### 闭包？

闭包是由捆绑起来（封闭的）的函数和函数周围状态（**词法环境**）的引用组合而成。闭包可以使函数访问它的外部作用域。由于闭包会保留对外部作用域的引用，如果这些引用没有得到及时释放，可能会导致内存无法被垃圾回收机制回收，引起内存泄露。

解决内存泄露的方法：闭包函数执行完后，手动解除对外部变量的引用，比如设置为null。避免在循环函数中创建闭包。注意闭包函数引用外部变量的生命周期，避免长时间对外部变量的引用。

##### 数组去重

1. [...new Set(arr)] 
2. arr.filter((value, index) => arr.indexOf(value) === index);
3. arr.sort().filter((value, index, self) => {        return index === 0 || value !== self[index - 1];    });

##### this指向问题？

function里面的this在使用new调用时，指向调用者。没有明确调用者的时候，默认指向window。对象里面的this指向对象自己，箭头函数不会创建this，所以它指向定义时外层作用域的this。

##### 箭头函数与普通函数的区别？

1. 语法更加简洁、清晰
2. 箭头函数不会创建自己的this
3. 箭头函数继承而来的this指向永远不变
4. .call()/.apply()/.bind()无法改变箭头函数中this的指向
5. 箭头函数不能作为构造函数使用
6. 箭头函数没有自己的arguments
7. 箭头函数没有原型prototype
8. 箭头函数不能用作Generator函数，不能使用yeild关键字

##### 二维数组去重

```javascript
let aa = [[1, 2], [2, 3], [1, 2]]
let obj = {};
aa.forEach(item => obj[item] = item);
aa = Object.values(obj);
console.log(aa);
```

##### 如何理解JS的异步

JS是一门单线程语言，这是因为它运行在浏览器的渲染主线程中，渲染主线程只存在一个。渲染主线程承担着诸多的工作，渲染页面、执行JS都在其中运行。如果采用同步的方式，极有可能导致主线程产生阻塞，从而导致消息队列中的其他任务无法得到执行。这样会导致繁忙的主线程消耗时间，页面无法及时更新，造成页面卡死。浏览器采用异步的方式，当例如计时、网络、事件监听等任务中，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码，当其他线程完成时，会将事先传递的回调函数包装成任务，加入到消息队列的末尾，等待主线程调度执行。

##### JS的计时器能够准确计时么？

计算机硬件没有原子钟，不能做到精确计时

JS计时器最终调用的是操作系统的函数，本身就存在少量偏差

根据W3C标准，浏览器计时器嵌套超过五层，会带有最少4ms的延时

事件循环的影响，计时器的回调函数只能在主线程空闲时运行

#### 计算机网络

##### 输入URL之后发生了什么

DNS解析。客户端输入URL后，会有一个递归查找的过程，从浏览器的缓存中查找，本地hosts文件查找，从本地DNS解析器缓存查找，本地DNS服务器查找。本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器地址。本地域名服务器向顶级域名服务器发起请求，获得权威域名服务器的地址。本地域名服务器向权威域名服务器发起请求，获得了域名对应的IP地址。

建立TCP连接。首先判断是不是https，如果是https，在http上多了一层处理加密信息的模块。进行三次握手：第一次握手，客户端发送请求报文段，SYN置为1，seq为x，客户端进入SYN_SEND状态，等待服务端确认，第二次握手服务端收到SYN后进行确认，设置ack为x+1，发送SYN请求信息，SYN位置为1，seq为y，服务端进入SYN_RECV状态。第三次握手，客户端接收到服务器的SYN+ACK报文段，将ack设置为y+1，向服务端发送ack。客户端和服务端进入了ESTABLISHED状态。

服务器处理请求，返回响应结果。服务器解析请求头，如果头部有缓存的相关信息，比如if-none-match和if-modified-since字段，验证缓存是否有效，有效返回304状态码。

关闭TCP连接。四次挥手，第一次挥手设置seq=x和ack，向主机2发送FIN报文段，主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了。第二次挥手主机2接收到FIN，向主机1返回ack为x+1，进入FIN_WAIT_2状态。第三次挥手，主机2发送FIN报文段，进入LAST_ACK状态。第四次挥手主机1向主机2发送ACK报文段，主机1进入TIME_WAIT状态，主机2收到ACK后关闭连接，主机1等待2MSL后没有收到回复关闭连接。

浏览器渲染。分为构建DOM树、样式计算、布局、分层、栅格化、显示阶段。渲染进程将HTML转换为DOM树，渲染引擎将CSS样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式。创建布局树，计算元素的布局信息。对布局树进行分层，生成分层树。为每个图层绘制列表，提交到合成线程，合成线程将图层分图块，栅格化将图块转化为位图。合成线程发送绘制图块的命令给浏览器进程。浏览器进程根据指令生成页面，显示到显示器。

##### 强缓存和协商缓存

强缓存浏览器不会向服务器发送请求，直接从本地缓存中读取文件并返回状态码200

协商缓存会向服务器发送请求，服务器根据请求的请求头判断是否命中缓存，如果命中，返回状态码304，并带上新的response header通知浏览器从缓存读取资源

强缓存头：Expires：过期时间 Catche-Control 设置max-age 设置缓存的时长（优先级高于Expires）

协商缓存头：Last-Modified/If-Modified-Since和Etag/If-None-Match

Last-Modified是服务器向浏览器发送的最后的修改时间，Etag：服务器生成的前端缓存验证的标识

##### 针对css、js、html以及接口缓存等分别采用什么具体的缓存策略

html：动态内容，频繁更新，采用短期强缓存或者是协商缓存

css：变化不频繁，长期强缓存，css文件名添加hash值或者版本号，文件变更的时候获取最新资源

js：与css类似，长期强缓存+文件名，或者使用协商缓存

接口缓存：实时性较高不缓存，Cache-control：no-cache或者no-store，get请求可以缓存，post请求通常不缓存。

##### 前端强制不使用缓存的方法

1. 设置请求的HTTP头，请求头加入Cache-Control:no-cache或者Cache-Control：no-store来强制客户端不使用缓存。no-cache会强制浏览器与服务器进行协商缓存检查，no-store完全禁用缓存。
2. URL添加动态参数，URL添加动态查询参数比如时间戳来避免缓存
3. 浏览器的开发者工具下面勾选Disable Cache

##### 浏览器读缓存的策略，读取顺序？

根据缓存的存储位置和缓存的有效性决定，常见的读缓存的的存储策略包括Memory Cache、Disk Cache、Push Cache、Service Worker Cache

Memory Cache是临时存储在内存中，用于当前页面生命周期的资源缓存，Disk Cache磁盘缓存存储在本地硬盘上，存储时间更长，Service Worker Cache离线缓存，需要额外编写sevice worker脚本，可以拦截网络请求为其提供缓存的资源。push cache 推送缓存http2使用，允许服务器在客户端发起请求之前将资源推送到客户端，生命周期为会话期间。

顺序：Memory Cache、Service Worker Cache、Disk Cache、Push Cache

##### cookie的属性

name=value 键值对

Expires/Max-Age：控制过期时间

domain：cookie适用的域名

Path：cookie适用的路径

secure：只能通过https传输

httponly：cookie只能被http请求，不可以被js脚本访问，防止xss攻击

SameSite：是否禁止跨站请求发送，防止CSRF攻击

##### cookie的SameSite有几种模式

strict：完全禁止第三方cookie，只有网页url与目标请求一致才会带上cookie

lax：除了导航到目标网址的get请求外不带cookie

none：必须同时设置secure属性，生效为默认值lax

##### 判断ip是不是内网ip

内网ip范围：

10.X.X.X
192.168.X.X
172.16.X.X-172.31.X.X

##### HTTP2.0的特性

二进制分帧：HTTP1.x的解析是基于文本，基于文本协议的格式解析天然存在缺陷，文本的表现形式多样，采用二进制，实现方便且健壮。

多路复用：即连接共享，每一个request都是有连接共享机制的，一个request对应一个id，一个连接可以有多个request id，接收方可以根据request id将request归属到不同的服务器请求里。

header压缩：通讯双方各自cache一份header fields表，避免了header的重复传输，减少了传输大小

服务端推送

##### HTTP3.0

基于UDP的QUIC协议，无队友堵塞，保证每个数据包的正确性，每个数据包会有一个唯一标识，当某个stream的一个数据包丢失，这个stream的其他数据包即使到达了HTTP也不会被读取，直到QUIC重传丢失的数据。

QUIC连接建立更快，握手过程只需要确认双方的连接ID即可。

支持连接迁移：不使用IP和端口来确定连接，而是通过连接ID来标记通信两端。

##### http和https区别

1. http默认端口80，https默认端口443
2. http明文传输，安全性差，https加密传输
3. https需要到CA申请证书
4. http响应速度快，三次握手交换三个包，https还要加上ssl握手的9个包
5. https是建立在SSL/TLS上面的HTTP协议，更加耗费服务器资源

##### get post的区别

1. get回退无害，post会再次提交请求
2. get请求会被浏览器主动catche，post不会
3. get只支持url编码，post支持多种编码方式
4. get请求在url传送的参数有长度限制，post没有
5. get接受ASCII字符，POST没有限制
6. get更加不安全，参数通过url传递，post放在request body中

##### CSRF攻击

跨站请求伪造是恶意站点程序通过已认证的用户的浏览器在受信任站点上执行的非正常操作。

防范的方式主要有：1.不使用cookie，使用localstorage 2. Cookie设置SameSite，当前源与cookie源相同的时候才发送cookie 3. 使用CSRF token，属于额外的token，一次性用完失效。4.检查Referrer字段确保请求的来源，依赖浏览器的安全性

##### async和defer

script标签的两个属性

defer告诉浏览器不要等待脚本，浏览器会继续处理HTML，构建DOM，脚本在后台加载，DOM完全构建之后，DOMContentLoaded事情触发之前执行，同时defer脚本会保持脚本的相对顺序。

async脚本会在后台加载完立即执行，不会保持脚本的相对顺序。

##### http状态码

201 created 资源创建成功

204 No content 服务器不会发送响应体

206 Partial Content 客户端指定Range范围请求头，服务端返回部分资源

301 重定向url 永久转移

302 重定向url 暂时转移

304 没有修改，使用缓存的内容

307 临时重定向 不指定客户端的请求方法

401 无权限

403 服务端拒绝请求

404 未找到

501 服务器不支持请求方法

502 错误网关

504 服务器到网关的请求超时

505不支持请求的http版本

##### 应用层协议包括什么，默认的端口号是什么？

HTTP 80 HTTPS 443 FTP 21 POP3 110 IMAP 143 DNS 53 DHCP 67/68 SSH 22

##### v8的垃圾回收策略

分代垃圾回收机制，年轻代存储新创建的对象，通常较小，老年代存储多次垃圾回收依然存在的对象。新生代采用复制算法，将内存复制为两个相等的区域，垃圾回收开始的时候从根对象开始，将存活的对象复制到To空间，然后清空From空间。老生代采用标记清除法，从根节点开始标记所有可达对象，然后清除未被标记的节点。

##### 进程和线程？多线程可能发生什么问题？

进程是操作系统的资源分配的基本单位，程序中运行的实例，每个进程都有独立的内存空间和系统资源，包括代码、数据、堆栈等信息。进程之间相互独立，创建和管理比线程复杂。

线程是进程的执行单元，一个进程包含多个线程，线程共享进程的内存和资源，每个线程有自己的栈和寄存器。线程之间共享数据，通信更加高效，线程的创建和管理更为轻量。

可能发生死锁问题，发生死锁需要满足互斥、占有并等待、不可剥夺、循环等待条件

##### 进程的通信方式

匿名管道通信：管道是一种半双工的通信方式，只能有数据单向流动，只能在具有亲缘关系的进程间使用，进程的亲缘关系通常指父子进程。



管道通信、消息队列、信号量、套接字

##### 线程间同步方式

互斥锁、条件变量、读写锁

##### 线程同步的方式

互斥锁：一旦获取，就会上锁，且只能由该线程解锁，期间，其他线程无法获取

条件变量：当线程在等待某些满足条件时使线程进入睡眠状态，一旦条件满足，就唤醒，这样不会占用宝贵的互斥对象锁，实现高效

读写锁：适用于对数据结构的读操作次数多于写操作次数的场合。

信号量：信号量允许多个线程同时进入临界区

##### 浏览器的线程有哪些

1. GUI渲染线程。与JS线程互斥，负责渲染浏览器界面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制。
2. JS引擎线程。JS内核，处理JS脚本程序，运行代码。
3. 事件触发线程。控制事件循环，执行setTimeout等任务，添加到事件线程队列等待JS引擎处理。
4. 定时触发器线程。setInterval与setTimeout所在线程，触发定时。
5. 异步http请求线程。在XMLHttpRequest在连接后是通过浏览器新开一个线程请求

#### Webpack

##### tree-shaking的原理

去除冗余的代码，程序从入口文件出发，扫描所有的模块依赖，以及模块的子依赖，将它们链接起来生成一个抽象语法树，随后运行所有代码，查看哪些代码是用到过的，打好标记。前提是模块需要采用ES6的语法，Tree shaking依赖ES6的静态语法，export和import。

##### webpack打包过程

webpack会根据webpack.config.js去解析配置文件，找到入口文件后递归地解析项目中的依赖关系，然后递归解析所有的依赖模块，使用加载器loader来解析不同类型的文件。

##### webpack的loader和plugin区别

webpack本身只能处理.js和.json文件，loader可以让webpack去处理其他种类的文件，将这些文件转换为模组，让应用程序可以使用，添加到依赖图中。可以在webpack.config.js中去指定loader在module.rules中指定匹配的文件使用一个loader或者多个loader，执行顺序为从右到左。

plugin用来拓展webpack的功能，webpack的生命周期各个环节会提供钩子，开发者可以在生命周期节点通过plugin拓展webpack的功能。使用plugin时候，一般通过require引入需要的plugin，然后new 实例化后添加到plugin数组中。

##### webpack构建优化

**打包体积优化**

代码分割：将代码按需加载，而不是将所有代码都打包成一个文件

Tree shaking：剔除无用的代码，分析代码依赖图，只打包用到的代码

按需加载第三方的库：比如引入 `lodash` 时，可以使用 `lodash-es` 或按需加载单个模块，而不是整个库。

**资源优化**

CDN加速

图片压缩

**缓存优化**

文件指纹：为静态资源文件添加文件哈希，通过 `webpack` 的 `contenthash` 功能，确保文件名变化能够触发浏览器的缓存更新

**减少JS执行时间**

代码压缩：使用 Terser 等工具进行代码压缩，减少文件体积。可以通过 `terser-webpack-plugin` 插件进行压缩。

使用合适的 polyfill：只为目标浏览器加载必要的 polyfill，避免引入不必要的代码。可以借助 `@babel/preset-env` 配合 `core-js` 实现按需引入。

##### webpack分包策略

1. 根据业务不同配置多个打包入口，输出多个打包结果；
2. 结合 ES Modules 的动态导入（Dynamic Imports）特性，按需加载模块

##### 性能指标

FP：表示渲染出第一个像素点

FCP：表示渲染出第一个内容

LCP：最大内容渲染时间。

FMP：首次渲染有意义的内容的时间

#### DOM/BOM

##### 事件委托？target和currTarget区别？

不为每个子节点单独设置事件监听器，利用事件冒泡机制，事件绑定在父元素上，子元素触发事件冒泡到父元素，父元素通过判断event.target执行相应的逻辑。可以大大减少DOM操作次数，提高性能。target指向最深层的元素，用户实际点击的元素。currentTarget指向事件监听器绑定的元素。

#### React

##### react中element和component的区别

元素是构成React的基本块，描述用户界面某个部分的对象，元素是不可变的，一旦创建无法更改。组件是指可以复用的UI组件，可以是类组件或者是函数组件，接受props，返回一个React元素。

##### 判断链表有环的方法

快慢指针、哈希表法

##### useEffect和useLayoutEffect的区别

useEffect是渲染之后执行

useLayoutEffect是渲染之前执行

##### react fiber怎么实现的，哪个api判断主线程空闲，怎么知道浏览器空闲？react用哪个api实现调度

React Fiber 是通过以下几个方面来优化渲染性能的：

- **时间分片**：Fiber 将渲染任务拆分成多个小单元，每次只执行一部分渲染任务，并且在主线程有空闲的时候再继续执行。这使得渲染过程不会一次性阻塞用户交互。
- **优先级调度**：Fiber 能为不同的更新赋予不同的优先级，比如用户输入、动画等高优先级任务会优先处理，非关键任务（如低优先级的数据更新）则可以延迟处理。
- **任务的可中断性**：在传统 React 中，渲染是不可中断的，而在 Fiber 中，渲染任务可以被中断并且稍后恢复，从而提升响应性。

Fiber 实现了一个**双缓冲机制**，也就是工作中的 Fiber 和当前的 Fiber 树（已渲染的 DOM 状态）。更新的时候，React 会构建工作中的 Fiber 树（也就是新 Fiber 树），并在合适的时候切换到新的树，从而将变化应用到 DOM 上。

React 使用了 `requestIdleCallback` API 来判断主线程何时空闲。在浏览器没有原生支持 `requestIdleCallback` 的情况下，React 使用了基于时间片的调度算法，使用类似 `setTimeout` 或 `MessageChannel` 来模拟空闲时间，定期检查并分配空闲时间给任务。

`MessageChannel` 可以创建一个简单的事件循环，并且拥有较好的跨浏览器兼容性和性能表现，允许在两个不同的上下文之间创建一个消息通道，能够异步执行任务，且比 `setTimeout` 的执行延迟更低

##### React 18新特性

1. 并发渲染模式
2. setState自动批处理
3. flushsync可以推出批量更新
4. React18的组件可以返回undefined
5. Suspense组件不再跨越边界
6. useId，useTransition

#### Typescript

##### ts的编译器叫什么

tsc是官方的命令行编译器

##### 泛型是什么？

定义函数、接口或者类的时候不预先指定具体的类型，而是在使用的时候在指定具体类型。

#### 智力题

##### 一个赛场中有5条赛道，现在有25匹马，在没有定时器的前提下最少跑多少圈可以角逐出前三名？前四名？前五名？

7、8、8/9

##### 设有12个外表一模一样的小球，其中11个重量完全相同，被称为好球，1个重量比好球重一点或者轻一点，被称为坏球。现在给你一架天平，请用天平称3次，把这个坏球找出来，还要知道它到底是轻的还是重的

首先我们把小球分成A、B、C三组。其中每组各有4个小球。 第一次使用天平时我们把A组和B组分别放在天平的左右两边。我们用 AAAA | BBBB 来表示。这时，我们会有三种可能的结果：

AAAA = BBBB，两端平衡。这意味着坏球是一个C球。 此时，我们可以这样称：AAA |  CCC。即用3个好球和3个可能的坏球进行比较。有三种可能的结果：
AAA = CCC，则意味着坏球在剩下的那个C球中。我们只要把它与任意一个好球放到天平两边称就可以知道这个C球是重球还是坏球；
AAA < CCC，即左轻右重，这意味着坏球一定在右边这3个C球中并且一定是重球。我们只要拿出其中任意两个C球放到天平两边，那边低哪个C球就是坏球；如果两边平衡则剩下的那个C球就是坏球，且一定是重球；
AAA > CCC，即左重右轻，这意味着坏球一定在右边这3个C球中并且一定是轻球。我们用类似的方法只用一次天平同样可以找出这个轻球。这里我们有定理：如果有3个球，且知道坏球是重的还是轻的，则用天平称一次就能找出坏球。
AAAA < BBBB，左轻右重。这意味着坏球如果是轻球，那它一定是个A球；如果它是个重球，则它一定是个B球。C球当然都是好球啦。我们把天平右边3个B球拿到一边去，只留下1个B球。然后从天平左边拿3个A球放倒右边。再拿3个C球（C球都是好球）放在天平左边，即：ACCC | AAAB 。这样我们会得到3个可能的结果。
ACCC = AAAB，则意味着拿下来的3个B球中有一个是坏球且一定是重球。根据上面定理，我们再用一次天平就能从这个3个B球中找到这个重球！
ACCC < AAAB，这意味着坏球要么是左边的那个唯一的A球，要么是右边的那个唯一B球，其他的A球和B球统统都是好球。我们用天平再称一次A与一个好球就能判断A和B中哪个是坏球且能知道它是重的还是轻的；
ACCC > AAAB，这意味着天平右边的3个A球中一定有一个坏球，且一定是轻球。根据上面定理，我们再称一次天平就能从这3个A球中找到这个轻球！
AAAA > BBBB，这种情况是AAAA < BBBB的对称情形，只需把上面讨论中的A换成B，B换成A就能解决。
