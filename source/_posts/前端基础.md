---
title: 前端基础
tags:
  - 前端
  - 面试
categories:
  - 前端
abbrlink: 48395
date: 2024-03-28 20:08:02
---
<!--more-->

## API

1. ##### arr.includes()

   判断一个数组是否包含一个指定的值，如果是返回 true，否则false

   ```javascript
   arr.includes(searchElement)
   arr.includes(searchElement, fromIndex)//fromIndex 从该索引处进行查找，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索
   ```

2. ##### arr.slice()

   slice() 方法可从已有的数组中返回选定的元素。

   slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。

   **注意：** slice() 方法不会改变原始数组

   ```javascript
   arr.slice()
   arr.slice(start)
   arr.slice(start, end)
   //start和end是数组的索引（可为负数） 从第start开始截取到end（不包含）结束
   ```

   

3. ##### str.lastIndexOf()

   搜索该字符串并返回指定子字符串最后一次出现的索引，如果找到了 `searchString`，则返回最后一次出现的索引，否则返回 `-1`。

   ```javascript
   str.lastIndexOf(searchString)
   str.lastIndexOf(searchString, position)//返回指定子字符串在小于或等于 position 的位置中的最后一次出现的索引, 默认为 +Infinity
   ```

4. ##### Map对象

   ###### Map()

   ```javascript
   new Map()
   new Map(iterable)//iterable是键值对数组或者其他可迭代对象，
   //eg：const myMap = new Map([[1, "one"],[2, "two"],[3, "three"]]);
   ```

5. **JavaScript 位运算符**

   判断`n`是否是2的整数次幂可以采用`(n & (n - 1)) == 0`

   | &    | AND          | 如果两位都是 1 则设置每位为 1                            |
   | ---- | ------------ | -------------------------------------------------------- |
   | \|   | OR           | 如果两位之一为 1 则设置每位为 1                          |
   | ^    | XOR          | 如果两位只有一位为 1 则设置每位为 1                      |
   | ~    | NOT          | 反转所有位                                               |
   | <<   | 零填充左位移 | 通过从右推入零向左位移，并使最左边的位脱落。             |
   | >>   | 有符号右位移 | 通过从左推入最左位的拷贝来向右位移，并使最右边的位脱落。 |
   | >>>  | 零填充右位移 | 通过从左推入零来向右位移，并使最右边的位脱落。           |

   

## 问答

1. ##### var、let、const 的差异？

   Var、let、const都可以用作变量的声明。

   var声明的变量会添加到全局对象中，可以使用全局对象进行访问，let和const不能。

   var声明的变量存在变量提升，在声明之前可以访问不会报错，let和const声明的变量存在暂时性死区，不能提前访问。

   let和const是块级作用域，不可以在一个作用域内重复声明，var是函数作用域。

   const声明的常量不可以修改，引用类型不能修改指针。

2. ##### **for in和for of**的区别

   两者都是遍历的方法，for in用于遍历索引，for of用于遍历元素值。

   for in多用于遍历对象，因为for in在遍历数组的索引的时候，索引的值为字符串类型，同时也会遍历数组的所有可枚举属性，包括原型上的方法和属性，这通常不是我们想要的。

   for of用遍历数/数组对象/字符串/`map`/`set`等拥有迭代器对象（`iterator`）的集合，但是不能遍历对象，因为没有迭代器对象。

2. 

## 算法

动态规划通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果。动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。

bfs中每一层要用新的变量保存
